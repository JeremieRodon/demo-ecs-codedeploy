AWSTemplateFormatVersion: "2010-09-09"
Description: "Simplified ECS CodeDeploy Demo - ECR push triggers CodeDeploy via EventBridge"

# This CloudFormation template creates a complete Blue/Green deployment pipeline for ECS containers.
# When you push a new image to ECR, it automatically triggers a Blue/Green deployment via CodeDeploy.
# The deployment includes integration testing to ensure the new version works before switching traffic.

Parameters:
  ProjectName:
    Type: String
    Default: "ecs-codedeploy-demo"
    Description: "Name of the project - used to name all resources consistently"

Resources:
  # =============================================================================
  # SECURITY GROUPS
  # =============================================================================
  # Security Groups are like firewalls - they control what traffic is allowed in/out
  # Think of them as bouncer rules: "Allow HTTP from anywhere, but block everything else"

  # Security Group for the Application Load Balancer (ALB)
  # This controls what traffic can reach our load balancer from the internet
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for ALB - allows HTTP traffic from internet"
      VpcId:
        Fn::ImportValue: !Sub "${ProjectName}-VPC"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80 # Production HTTP traffic
          ToPort: 80
          CidrIp: "0.0.0.0/0" # Allow from anywhere on the internet
        - IpProtocol: tcp
          FromPort: 8080 # Test HTTP traffic (for Blue/Green testing)
          ToPort: 8080
          CidrIp: "0.0.0.0/0" # Allow from anywhere on the internet
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-alb-sg"

  # Security Group for ECS Tasks (our containers)
  # This only allows traffic from the ALB - containers can't be reached directly from internet
  # This is a security best practice: only the load balancer can talk to the containers
  ECSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for ECS tasks - only allows traffic from ALB"
      VpcId:
        Fn::ImportValue: !Sub "${ProjectName}-VPC"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80 # HTTP port on containers
          ToPort: 80
          SourceSecurityGroupId: !Ref ALBSecurityGroup # Only allow traffic from ALB
      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-ecs-sg"


  # =============================================================================
  # APPLICATION LOAD BALANCER (ALB)
  # =============================================================================
  # The ALB distributes incoming traffic across multiple containers
  # It's also key to Blue/Green deployments - it can switch traffic between versions

  # Application Load Balancer - The entry point for all web traffic
  # This is what users connect to; it forwards requests to healthy containers
  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${ProjectName}-alb"
      Scheme: internet-facing # Can be reached from the internet
      Type: application # Layer 7 load balancer (HTTP/HTTPS)
      SecurityGroups:
        - !Ref ALBSecurityGroup # Use our ALB security group
      Subnets:
        - Fn::ImportValue: !Sub "${ProjectName}-PublicSubnet1" # Deploy across both subnets for high availability
        - Fn::ImportValue: !Sub "${ProjectName}-PublicSubnet2"

  # Target Groups for Blue/Green Deployments
  # Target Groups are like "buckets" that hold containers
  # CodeDeploy alternates between Blue and Green with each deployment
  # Initially: Blue = production, Green = new. Next deployment: Green = production, Blue = new

  # Blue Target Group - One of two target groups for Blue/Green deployments
  # Will alternate between holding current production and new version
  BlueTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${ProjectName}-blue"
      Port: 80 # Port that containers listen on
      Protocol: HTTP
      TargetType: ip # Targets are IP addresses (for Fargate)
      VpcId:
        Fn::ImportValue: !Sub "${ProjectName}-VPC"
      HealthCheckPath: / # URL path to check if container is healthy
      HealthCheckIntervalSeconds: 30 # How often to check health
      HealthyThresholdCount: 2 # Healthy after 2 successful checks
      UnhealthyThresholdCount: 3 # Unhealthy after 3 failed checks

  # Green Target Group - One of two target groups for Blue/Green deployments
  # Will alternate between holding current production and new version
  GreenTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${ProjectName}-green"
      Port: 80 # Port that containers listen on
      Protocol: HTTP
      TargetType: ip # Targets are IP addresses (for Fargate)
      VpcId:
        Fn::ImportValue: !Sub "${ProjectName}-VPC"
      HealthCheckPath: / # URL path to check if container is healthy
      HealthCheckIntervalSeconds: 30 # How often to check health
      HealthyThresholdCount: 2 # Healthy after 2 successful checks
      UnhealthyThresholdCount: 3 # Unhealthy after 3 failed checks

  # ALB Production Listener - Handles real user traffic on port 80
  # Initially routes to Blue target group, but CodeDeploy will alternate between
  # Blue and Green target groups with each deployment
  # DependsOn both target groups to prevent deletion issues when CodeDeploy has inverted target group assignments
  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - BlueTargetGroup
      - GreenTargetGroup
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref BlueTargetGroup # Start with Blue (current production)
      LoadBalancerArn: !Ref ALB
      Port: 80 # Production traffic (what users see)
      Protocol: HTTP

  # ALB Test Listener - Handles test traffic on port 8080
  # This always routes to whichever target group contains the NEW version during deployment
  # Integration tests will connect to this port to validate the new deployment
  # DependsOn both target groups to prevent deletion issues when CodeDeploy has inverted target group assignments
  ALBTestListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - BlueTargetGroup
      - GreenTargetGroup
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref GreenTargetGroup # Routes to Green (new version under test)
      LoadBalancerArn: !Ref ALB
      Port: 8080 # Test traffic (for integration tests)
      Protocol: HTTP

  # =============================================================================
  # ECS (CONTAINER ORCHESTRATION) INFRASTRUCTURE
  # =============================================================================
  # ECS = Elastic Container Service - AWS's container orchestration service
  # Think of it as a smart system that runs and manages your Docker containers
  # It's like Kubernetes but AWS-managed

  # ECS Task Execution Role - Permissions for ECS to run our containers
  # This role allows ECS to pull images from ECR, write logs to CloudWatch, etc.
  # Think of it as giving ECS permission to do its job of running containers
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com # Only ECS can use this role
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy # Standard ECS permissions

  # =============================================================================
  # ECS TASK DEFINITION
  # =============================================================================
  # Defines what containers to run and how to run them
  # This is like a "recipe" for creating containers
  #
  # IMPORTANT: TaskDefinition Override Behavior
  # ==========================================
  # This TaskDefinition is created by CloudFormation with the ":latest" tag,
  # but it will be OVERRIDDEN by the first CodePipeline execution!
  #
  # Here's what happens:
  # 1. CloudFormation creates this TaskDefinition with ":latest" tag
  # 2. ECS Service starts using this TaskDefinition (not great for production)
  # 3. First pipeline execution creates a NEW TaskDefinition with SHA256 hash
  # 4. CodeDeploy updates the ECS Service to use the new TaskDefinition
  # 5. Future deployments continue using SHA256-hashed TaskDefinitions
  #
  # This is actually GOOD because:
  # - ":latest" is unpredictable (could change without notice)
  # - SHA256 hashes are immutable and precise
  # - Enables exact rollbacks to specific image versions
  # - Provides deployment traceability and auditability
  ECSTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref ProjectName # Family name groups related task definitions
      NetworkMode: awsvpc # Each container gets its own network interface
      RequiresCompatibilities:
        - FARGATE # Must run on Fargate (serverless)
      Cpu: 256 # 0.25 vCPU (256 CPU units)
      Memory: 512 # 512 MB RAM
      ExecutionRoleArn: !Ref ECSTaskExecutionRole
      ContainerDefinitions:
        - Name: demo-app # Container name
          Image: !Sub
            - "${ECRRepositoryURI}:latest" # TEMPORARY: Will be replaced by CodeDeploy with SHA256 hash
            - ECRRepositoryURI:
                Fn::ImportValue: !Sub "${ProjectName}-ECRRepositoryURI"
          Essential: true # If this container stops, the task stops
          PortMappings:
            - ContainerPort: 80 # Container listens on port 80
              Protocol: tcp

  # =============================================================================
  # ECS Service - Manages our containers and keeps them running
  # =============================================================================
  # This is like a supervisor that ensures we always have the right number of healthy containers
  # With CODE_DEPLOY controller, deployments are handled by CodeDeploy (Blue/Green)
  #
  # IMPORTANT: ECS Service Override Behavior
  # =======================================
  # This ECS Service is initially created with the CloudFormation TaskDefinition,
  # but CodeDeploy will UPDATE this service during the first pipeline execution!
  #
  # Here's what happens:
  # 1. CloudFormation creates this service with initial TaskDefinition (":latest")
  # 2. Service starts running containers with the ":latest" image
  # 3. First pipeline execution triggers CodeDeploy
  # 4. CodeDeploy creates a NEW TaskDefinition with SHA256 image hash
  # 5. CodeDeploy UPDATES this service to use the new TaskDefinition
  # 6. Blue-green deployment switches traffic to new version
  # 7. Old TaskDefinition is deregistered after successful deployment
  #
  # This service configuration gets "taken over" by CodeDeploy:
  # - CodeDeploy manages precise version deployments
  # - Enables controlled blue-green deployments with testing
  # - Provides rollback capabilities to specific versions
  # - Ensures zero-downtime deployments
  #
  # The DeploymentController: CODE_DEPLOY setting is crucial - it tells ECS
  # to let CodeDeploy handle deployments instead of doing rolling updates.
  ECSService:
    Type: AWS::ECS::Service
    DependsOn: ALBListener # Must wait for ALB listener to be ready
    Properties:
      ServiceName: !Ref ProjectName
      Cluster:
        Fn::ImportValue: !Sub "${ProjectName}-ECSCluster"
      TaskDefinition: !Ref ECSTaskDefinition  # TEMPORARY: Will be updated by CodeDeploy
                                              # Also note that you CANNOT update this in
                                              # CloudFormation when using CODE_DEPLOY as
                                              # a DeploymentController to prevent shooting
                                              # yourself in the foot.
      LaunchType: FARGATE # Run on Fargate (serverless)
      DesiredCount: 2 # Always run 2 containers for availability
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref ECSSecurityGroup # Use our ECS security group
          Subnets:
            - Fn::ImportValue: !Sub "${ProjectName}-PublicSubnet1" # Deploy containers across both subnets
            - Fn::ImportValue: !Sub "${ProjectName}-PublicSubnet2"
          AssignPublicIp: ENABLED # Required for Fargate containers to pull images
      LoadBalancers:
        - ContainerName: demo-app # Must match the container name in the task definition
          ContainerPort: 80 # Must match the port in the task definition
          TargetGroupArn: !Ref BlueTargetGroup # Initially routes to Blue target group
      DeploymentController:
        Type: CODE_DEPLOY # Use CodeDeploy for Blue/Green deployments


  # =============================================================================
  # INTEGRATION TEST LAMBDA FUNCTION
  # =============================================================================
  # This Lambda function runs integration tests on new deployments
  # It validates the new version before traffic is switched to it
  # If tests fail, CodeDeploy will automatically rollback

  # CloudWatch Log Group for Integration Test Lambda
  # Creating explicit log group ensures it's included in cleanup and has proper retention
  # Using minimum retention (1 day) to minimize costs while keeping recent logs for debugging
  IntegrationTestLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${ProjectName}-integration-test"
      RetentionInDays: 1 # Minimum retention - logs kept for 1 day only

  # Integration Test Lambda Role - Permissions for the test function
  IntegrationTestLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com # Only Lambda can use this role
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole # Basic Lambda permissions
      Policies:
        - PolicyName: IntegrationTestPermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - codedeploy:PutLifecycleEventHookExecutionStatus # Report test results back to CodeDeploy
                Resource: "*"

  # Integration Test Lambda Function - Validates deployments before traffic switch
  # This function is called by CodeDeploy during the AfterAllowTestTraffic lifecycle event
  # It performs 3 tests: connectivity, content validation, and performance
  # If any test fails, the deployment is automatically rolled back
  IntegrationTestFunction:
    Type: AWS::Lambda::Function
    DependsOn: IntegrationTestLogGroup # Ensure log group exists before function
    Properties:
      FunctionName: !Sub "${ProjectName}-integration-test"
      Runtime: python3.13 # Python runtime for the Lambda function
      Handler: index.lambda_handler # Entry point function
      Role: !GetAtt IntegrationTestLambdaRole.Arn # IAM role for permissions
      Timeout: 30 # Maximum execution time in seconds
      Environment:
        Variables:
          ALB_DNS_NAME: !GetAtt ALB.DNSName # Load balancer DNS name for testing
          TEST_PORT: "8080" # Test listener port (Green target group)
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import time
          import os

          codedeploy = boto3.client('codedeploy')
          http = urllib3.PoolManager()

          def lambda_handler(event, context):
              print(f"Integration test started (AfterAllowTestTraffic): {json.dumps(event)}")

              # Extract CodeDeploy event information
              deployment_id = event.get('DeploymentId')
              lifecycle_event_hook_execution_id = event.get('LifecycleEventHookExecutionId')

              if not deployment_id or not lifecycle_event_hook_execution_id:
                  print("ERROR: Missing required CodeDeploy event parameters")
                  return {
                      'statusCode': 400,
                      'body': 'Missing required parameters'
                  }

              try:
                  # Test configuration
                  alb_dns = os.environ['ALB_DNS_NAME']
                  test_port = os.environ['TEST_PORT']
                  test_url = f"http://{alb_dns}:{test_port}"

                  print(f"Testing URL (via test listener): {test_url}")

                  print(f"[QUICK&DIRTY] Sleeping 20 secs to make sure the endpoint is actually on the test version...")
                  time.sleep(20)

                  # Perform integration tests after test traffic is routed
                  test_results = []

                  # Test 1: Basic connectivity
                  print("Test 1: Basic connectivity check via test listener")
                  response = http.request('GET', test_url, timeout=30.0)
                  if response.status == 200:
                      test_results.append({"test": "connectivity", "status": "PASS"})
                      print("✓ Connectivity test passed")
                  else:
                      test_results.append({"test": "connectivity", "status": "FAIL", "details": f"HTTP {response.status}"})
                      print(f"✗ Connectivity test failed: HTTP {response.status}")

                  # Test 2: Content validation
                  print("Test 2: Content validation")
                  if response.status == 200:
                      content = response.data.decode('utf-8')

                      # Check for specific failure indicator (v4.0 will include this)
                      if "TEST_FAILURE_TRIGGER" in content:
                          test_results.append({"test": "content_validation", "status": "FAIL", "details": "Application contains failure trigger"})
                          print("✗ Content validation failed: Application marked for failure")
                      elif "ECS CodeDeploy Demo" in content:
                          test_results.append({"test": "content_validation", "status": "PASS"})
                          print("✓ Content validation passed")
                      else:
                          test_results.append({"test": "content_validation", "status": "FAIL", "details": "Expected content not found"})
                          print("✗ Content validation failed: Expected content missing")
                  else:
                      test_results.append({"test": "content_validation", "status": "SKIP", "details": "Skipped due to connectivity failure"})

                  # Test 3: Performance check (response time)
                  print("Test 3: Performance check")
                  if response.status == 200:
                      start_time = time.time()
                      perf_response = http.request('GET', test_url, timeout=30.0)
                      response_time = time.time() - start_time

                      if response_time < 5.0:  # 5 second threshold
                          test_results.append({"test": "performance", "status": "PASS", "details": f"Response time: {response_time:.2f}s"})
                          print(f"✓ Performance test passed: {response_time:.2f}s")
                      else:
                          test_results.append({"test": "performance", "status": "FAIL", "details": f"Response time too slow: {response_time:.2f}s"})
                          print(f"✗ Performance test failed: {response_time:.2f}s")
                  else:
                      test_results.append({"test": "performance", "status": "SKIP", "details": "Skipped due to connectivity failure"})

                  # Determine overall test result
                  failed_tests = [t for t in test_results if t["status"] == "FAIL"]
                  overall_status = "Failed" if failed_tests else "Succeeded"

                  print(f"Integration test results: {json.dumps(test_results, indent=2)}")
                  print(f"Overall status: {overall_status}")

                  # Report results to CodeDeploy
                  codedeploy.put_lifecycle_event_hook_execution_status(
                      deploymentId=deployment_id,
                      lifecycleEventHookExecutionId=lifecycle_event_hook_execution_id,
                      status=overall_status
                  )

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'overall_status': overall_status,
                          'test_results': test_results,
                          'deployment_id': deployment_id
                      })
                  }

              except Exception as e:
                  print(f"Integration test failed with exception: {str(e)}")

                  # Report failure to CodeDeploy
                  try:
                      codedeploy.put_lifecycle_event_hook_execution_status(
                          deploymentId=deployment_id,
                          lifecycleEventHookExecutionId=lifecycle_event_hook_execution_id,
                          status='Failed'
                      )
                  except Exception as cd_error:
                      print(f"Failed to report to CodeDeploy: {str(cd_error)}")

                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e),
                          'deployment_id': deployment_id
                      })
                  }

  # Permission for CodeDeploy to invoke Integration Test Lambda
  # This allows CodeDeploy to call our integration test function during deployments
  IntegrationTestInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref IntegrationTestFunction
      Action: lambda:InvokeFunction # Allow function invocation
      Principal: codedeploy.amazonaws.com # CodeDeploy service principal

  # =============================================================================
  # CODEDEPLOY (BLUE/GREEN DEPLOYMENT SERVICE)
  # =============================================================================
  # CodeDeploy manages Blue/Green deployments - it switches traffic safely between versions
  # It can automatically rollback if health checks fail

  # CodeDeploy Service Role - Permissions for CodeDeploy to manage deployments
  # This role allows CodeDeploy to update load balancers, manage ECS services, etc.
  CodeDeployServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codedeploy.amazonaws.com # Only CodeDeploy can use this role
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSCodeDeployRoleForECS # Standard CodeDeploy permissions
      Policies:
        - PolicyName: ELBPermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - elasticloadbalancing:DescribeTargetGroups # Read load balancer info
                  - elasticloadbalancing:DescribeListeners
                  - elasticloadbalancing:ModifyListener # Switch traffic between target groups
                  - elasticloadbalancing:DescribeRules
                  - elasticloadbalancing:ModifyRule
                Resource: "*"
              - Effect: Allow
                Action:
                  - iam:PassRole # Pass ECS role to new tasks
                Resource: !GetAtt ECSTaskExecutionRole.Arn

  # CodeDeploy Application - Top-level container for deployments
  # This is the main application that CodeDeploy will manage deployments for
  CodeDeployApplication:
    Type: AWS::CodeDeploy::Application
    Properties:
      ApplicationName: !Ref ProjectName
      ComputePlatform: ECS # We're deploying to ECS (not EC2 or Lambda)

  # CodeDeploy Deployment Group - Defines how deployments are executed
  # This is the configuration that tells CodeDeploy how to perform Blue/Green deployments
  CodeDeployDeploymentGroup:
    Type: AWS::CodeDeploy::DeploymentGroup
    Properties:
      ApplicationName: !Ref CodeDeployApplication
      DeploymentGroupName: !Sub "${ProjectName}-dg"
      ServiceRoleArn: !GetAtt CodeDeployServiceRole.Arn # Role for CodeDeploy permissions
      DeploymentConfigName: CodeDeployDefault.ECSCanary10Percent5Minutes # Deployment strategy
      # DeploymentConfigName: CodeDeployDefault.ECSAllAtOnce
      DeploymentStyle:
        DeploymentType: BLUE_GREEN # Use Blue/Green deployment (not rolling)
        DeploymentOption: WITH_TRAFFIC_CONTROL # Use load balancer to control traffic
      BlueGreenDeploymentConfiguration:
        TerminateBlueInstancesOnDeploymentSuccess:
          Action: TERMINATE # Shut down old containers after successful deployment
          TerminationWaitTimeInMinutes: 1 # Wait 1 minute before terminating
        DeploymentReadyOption:
          ActionOnTimeout: CONTINUE_DEPLOYMENT # Continue if no manual intervention
      ECSServices:
        - ServiceName: !GetAtt ECSService.Name # ECS service to deploy to
          ClusterName:
            Fn::ImportValue: !Sub "${ProjectName}-ECSCluster" # ECS cluster containing the service
      LoadBalancerInfo:
        TargetGroupPairInfoList:
          - ProdTrafficRoute:
              ListenerArns:
                - !Ref ALBListener # Production traffic listener (port 80)
            TestTrafficRoute:
              ListenerArns:
                - !Ref ALBTestListener # Test traffic listener (port 8080)
            TargetGroups:
              - Name: !GetAtt BlueTargetGroup.TargetGroupName # Blue target group
              - Name: !GetAtt GreenTargetGroup.TargetGroupName # Green target group
      AutoRollbackConfiguration:
        Enabled: true # Enable automatic rollback on failure
        Events:
          - DEPLOYMENT_FAILURE # Rollback if deployment fails
          - DEPLOYMENT_STOP_ON_REQUEST # Rollback if manually stopped


  # =============================================================================
  # CODEPIPELINE AUTOMATION
  # =============================================================================
  # CodePipeline orchestrates the entire deployment process from source to production
  #
  # PIPELINE FLOW OVERVIEW:
  # 1. SOURCE STAGE: Monitors ECR for new images and fetches deployment files
  # 2. DEPLOY STAGE: Uses CodeDeploy to perform blue-green deployment
  #
  # This creates a fully automated CI/CD pipeline:
  # Push Image → Trigger Pipeline → Deploy → Test → Go Live → Clean Up
  #
  # The pipeline is triggered automatically via EventBridge when you push
  # a new image to ECR, making deployments completely hands-off.

  # S3 Bucket for CodePipeline artifacts
  # CodePipeline needs a place to store intermediate artifacts between stages
  # This includes the ECR image information and deployment configuration files
  CodePipelineArtifactsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${ProjectName}-pipeline-artifacts-${AWS::AccountId}-${AWS::Region}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpiration:
              NoncurrentDays: 1

  # Custom Resource to empty artifacts bucket on stack deletion
  ArtifactsBucketEmptier:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !ImportValue
        Fn::Sub: "${ProjectName}-S3BucketEmptierFunctionArn"
      BucketName: !Ref CodePipelineArtifactsBucket

  # CodePipeline Service Role
  # This IAM role gives CodePipeline the permissions it needs to orchestrate deployments
  # It needs access to S3 (for artifacts), CodeDeploy (for deployments),
  # ECR (for images), and ECS (for task definitions)
  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codepipeline.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodePipelinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # S3 permissions: CodePipeline stores artifacts (like deployment configs) in S3
              # These are passed between pipeline stages
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:GetObjectVersion
                  - s3:ListBucket
                  - s3:GetBucketVersioning
                  - s3:GetBucketAcl
                  - s3:GetBucketLocation
                  - s3:GetObjectTagging
                  - s3:GetObjectVersionTagging
                Resource:
                  - !Sub arn:${AWS::Partition}:s3:::${CodePipelineArtifactsBucket}
                  - !Sub arn:${AWS::Partition}:s3:::${CodePipelineArtifactsBucket}/*
              # CodeDeploy permissions: CodePipeline triggers CodeDeploy to perform the actual deployment
              # It needs to create deployments and monitor their progress
              - Effect: Allow
                Action:
                  - codedeploy:CreateDeployment
                  - codedeploy:GetDeployment
                  - codedeploy:GetApplication
                  - codedeploy:GetApplicationRevision
                  - codedeploy:RegisterApplicationRevision
                  - codedeploy:GetDeploymentConfig
                Resource:
                  - !Sub "arn:${AWS::Partition}:codedeploy:${AWS::Region}:${AWS::AccountId}:deploymentgroup:${CodeDeployApplication}/${CodeDeployDeploymentGroup}"
                  - !Sub "arn:${AWS::Partition}:codedeploy:${AWS::Region}:${AWS::AccountId}:application:${CodeDeployApplication}"
                  - !Sub "arn:${AWS::Partition}:codedeploy:${AWS::Region}:${AWS::AccountId}:application:${CodeDeployApplication}/*"
                  - !Sub "arn:${AWS::Partition}:codedeploy:${AWS::Region}:${AWS::AccountId}:deploymentconfig:*"
              # ECR permissions: CodePipeline needs to describe images to get their SHA256 hashes
              # This is how it knows exactly which image version to deploy
              - Effect: Allow
                Action:
                  - ecr:DescribeImages
                Resource: !Sub
                  - "${ECRRepositoryArn}"
                  - ECRRepositoryArn:
                      Fn::ImportValue: !Sub "${ProjectName}-ECRRepositoryArn"
              # ECS permissions: CodePipeline needs to register new task definitions
              # This is part of the deployment process where it creates updated task definitions
              - Effect: Allow
                Action:
                  - ecs:RegisterTaskDefinition
                Resource: "*"
              # IAM permissions: CodePipeline needs to pass the execution role to ECS
              # This allows the new task definition to use the proper execution role
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt ECSTaskExecutionRole.Arn
                Condition:
                  StringEquals:
                    "iam:PassedToService":
                      - "ecs.amazonaws.com"
                      - "ecs-tasks.amazonaws.com"

  # Custom Resource to create CodeDeploy files artifact with taskdef.json and appspec.yaml
  # This creates the deployment configuration files that CodeDeploy needs
  # These files are stored in S3 as a zip artifact that the pipeline can reference
  CodeDeployFilesArtifact:
    Type: Custom::CodeDeployFilesArtifact
    # So the emptier deletetion can run after this one
    # and remove the Delete Marker of this file
    DependsOn: ArtifactsBucketEmptier
    Properties:
      ServiceToken: !ImportValue
        Fn::Sub: "${ProjectName}-CodePipelineArtifactCreatorFunctionArn"
      ArtifactBucket: !Ref CodePipelineArtifactsBucket
      ArtifactKey: "codedeploy-files-artifact.zip"
      Files:
        # taskdef.json: Template for the ECS task definition
        # The <IMAGE1_NAME> placeholder gets replaced by CodeDeploy with the actual image URI
        # This is how CodeDeploy knows which image to deploy
        - Name: "taskdef.json"
          Content: !Sub |
            {
              "family": "${ProjectName}",
              "executionRoleArn": "${ECSTaskExecutionRole.Arn}",
              "networkMode": "awsvpc",
              "requiresCompatibilities": ["FARGATE"],
              "cpu": "256",
              "memory": "512",
              "containerDefinitions": [
                {
                  "name": "demo-app",
                  "image": "<IMAGE1_NAME>",
                  "essential": true,
                  "portMappings": [
                    {
                      "containerPort": 80,
                      "protocol": "tcp"
                    }
                  ]
                }
              ]
            }
        # appspec.yaml: Tells CodeDeploy how to deploy the ECS service
        # The <TASK_DEFINITION> placeholder gets replaced with the actual task definition ARN
        # The Hooks section defines what happens after traffic is routed to the new version
        - Name: "appspec.yaml"
          Content: !Sub |
            version: 0.0
            Resources:
              - TargetService:
                  Type: AWS::ECS::Service
                  Properties:
                    TaskDefinition: <TASK_DEFINITION>
                    LoadBalancerInfo:
                      ContainerName: "demo-app"
                      ContainerPort: 80
            Hooks:
              - AfterAllowTestTraffic: "${IntegrationTestFunction}"

  # CodePipeline
  # This is the heart of the automated deployment system
  # It orchestrates the flow from source code to production deployment
  #
  # PIPELINE OVERRIDE BEHAVIOR:
  # ==========================
  # This pipeline will OVERRIDE the initial CloudFormation-created resources:
  # 1. Creates new TaskDefinition with precise SHA256 image reference
  # 2. Updates ECS Service to use the new TaskDefinition
  # 3. Performs blue-green deployment through CodeDeploy
  #
  # This transforms the deployment from ":latest" (imprecise) to SHA256 (precise)
  # and enables proper version control and rollback capabilities.
  #
  # SEQUENTIAL DEPLOYMENT ADVANTAGE:
  # ===============================
  # CodePipeline ensures strict deployment ordering - a major improvement over Lambda triggers:
  # - Rapid successive ECR pushes are safely queued (no race conditions)
  # - Each deployment waits for the previous one to complete before starting
  # - Eliminates Lambda crashes from concurrent CodeDeploy attempts
  # - Provides reliable deployment history and rollback capabilities
  CodePipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      Name: !Sub "${ProjectName}-pipeline"
      RoleArn: !GetAtt CodePipelineServiceRole.Arn
      ArtifactStore:
        Type: S3
        Location: !Ref CodePipelineArtifactsBucket
      PipelineType: V2 # Latest pipeline version with improved performance
      RestartExecutionOnUpdate: false # Don't restart when pipeline definition changes
      Stages:
        # SOURCE STAGE: Gather everything needed for deployment
        # This stage has TWO source actions that run in parallel
        - Name: Source
          Actions:
            # ECR Source Action: Monitors ECR for new images
            # This action triggers when EventBridge detects a new image push
            - Name: ECR
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: ECR
                Version: '1'
              Configuration:
                RepositoryName: !ImportValue
                  Fn::Sub: "${ProjectName}-ECRRepositoryName"
                ImageTag: "latest" # Monitors for latest tag pushes
              OutputArtifacts:
                - Name: ECRArtifact # Contains image URI with SHA256 hash
            # S3 Source Action: Fetches deployment configuration files
            # This gets the taskdef.json and appspec.yaml files created earlier
            - Name: CodeDeployFiles
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: S3
                Version: '1'
              Configuration:
                S3Bucket: !GetAtt CodeDeployFilesArtifact.BucketName
                S3ObjectKey: !GetAtt CodeDeployFilesArtifact.ArtifactKey
                PollForSourceChanges: false # Don't poll - triggered by EventBridge
              OutputArtifacts:
                - Name: CodeDeployFilesArtifact # Contains taskdef.json and appspec.yaml
        # DEPLOY STAGE: Perform the blue-green deployment
        # This is where the magic happens - CodeDeploy takes over
        - Name: Deploy
          Actions:
            # CodeDeploy Action: Orchestrates the blue-green deployment
            # This action combines the image info and deployment configs to create a deployment
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: CodeDeployToECS
                Version: '1'
              Configuration:
                ApplicationName: !Ref CodeDeployApplication
                DeploymentGroupName: !Ref CodeDeployDeploymentGroup
                # Task definition template (with <IMAGE1_NAME> placeholder)
                TaskDefinitionTemplateArtifact: CodeDeployFilesArtifact
                TaskDefinitionTemplatePath: taskdef.json
                # Application spec (defines deployment behavior)
                AppSpecTemplateArtifact: CodeDeployFilesArtifact
                AppSpecTemplatePath: appspec.yaml
                # Image information (will replace <IMAGE1_NAME> placeholder)
                Image1ArtifactName: ECRArtifact
                Image1ContainerName: IMAGE1_NAME
              InputArtifacts:
                - Name: ECRArtifact # Image information
                - Name: CodeDeployFilesArtifact # Deployment config files

  # EventBridge Role for CodePipeline
  # This role allows EventBridge to trigger CodePipeline executions
  # It's the bridge between "image pushed to ECR" and "deployment starts"
  EventBridgeCodePipelineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com # EventBridge service
            Action: sts:AssumeRole
      Policies:
        - PolicyName: StartPipelineExecution
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Permission to start the pipeline when ECR events are detected
              - Effect: Allow
                Action:
                  - codepipeline:StartPipelineExecution
                Resource: !Sub "arn:${AWS::Partition}:codepipeline:${AWS::Region}:${AWS::AccountId}:${CodePipeline}"

  # =============================================================================
  # EVENTBRIDGE AUTOMATION
  # =============================================================================
  # EventBridge automatically triggers deployments when new images are pushed to ECR
  # This creates a fully automated CI/CD pipeline: Push Image → Deploy → Test → Go Live

  # EventBridge Rule for ECR image push - Watches for ECR push events
  # When you push an image to ECR, this rule automatically triggers the deployment
  # This is the "magic" that makes push-to-deploy work without manual intervention
  #
  # WORKFLOW AUTOMATION:
  # 1. Developer pushes image to ECR (e.g., docker push <repo>:latest)
  # 2. ECR emits an "ECR Image Action" event to EventBridge
  # 3. This rule catches the event and triggers CodePipeline
  # 4. CodePipeline fetches the new image info and starts deployment
  # 5. CodeDeploy performs blue-green deployment with testing
  # 6. If tests pass, traffic shifts to new version
  # 7. If tests fail, automatic rollback occurs
  #
  # This creates a completely automated deployment pipeline!
  ECRImagePushRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "${ProjectName}-ecr-push"
      Description: "Trigger CodeDeploy when image is pushed to ECR"
      EventPattern:
        source:
          - "aws.ecr" # Listen for ECR service events
        detail-type:
          - "ECR Image Action" # Specifically image-related events
        detail:
          action-type:
            - "PUSH" # Only trigger on image push (not pull or delete)
          repository-name:
            - Fn::ImportValue: !Sub "${ProjectName}-ECRRepositoryName" # Only our repository
          result:
            - "SUCCESS" # Only trigger on successful pushes
      State: ENABLED # Rule is active
      Targets:
        - Arn: !Sub "arn:${AWS::Partition}:codepipeline:${AWS::Region}:${AWS::AccountId}:${CodePipeline}"
          Id: "TriggerPipelineTarget"
          RoleArn: !GetAtt EventBridgeCodePipelineRole.Arn

# =============================================================================
# OUTPUTS
# =============================================================================
# These outputs provide important information about the deployed resources
# They can be used by scripts, other stacks, or displayed to users

Outputs:
  # Primary application endpoint - this is where users access your application
  ALBUrl:
    Description: "Application Load Balancer URL - Main application endpoint"
    Value: !Sub "http://${ALB.DNSName}"
    Export:
      Name: !Sub "${ProjectName}-ALBUrl" # Export for use by other stacks

  # Test endpoint - used during blue-green deployments for validation
  # During deployment, new version is temporarily available on port 8080
  # Integration tests hit this endpoint to verify the deployment before going live
  TestUrl:
    Description: "Application Test URL (port 8080) - For testing new deployments"
    Value: !Sub "http://${ALB.DNSName}:8080"
    Export:
      Name: !Sub "${ProjectName}-TestUrl" # Export for use by other stacks

  # Lambda function that performs integration testing during deployments
  # This function is called by CodeDeploy during the blue-green deployment process
  # It validates that the new version is working correctly before traffic shifts
  IntegrationTestFunctionName:
    Description: "Integration Test Lambda Function Name - For monitoring and debugging"
    Value: !Ref IntegrationTestFunction
    Export:
      Name: !Sub "${ProjectName}-IntegrationTestFunction" # Export for use by other stacks

  # CodePipeline name for monitoring and troubleshooting deployments
  # You can use this to check deployment status in the AWS Console
  # aws codepipeline get-pipeline-state --name <pipeline-name>
  CodePipelineName:
    Description: "CodePipeline Name - For monitoring deployments"
    Value: !Ref CodePipeline
    Export:
      Name: !Sub "${ProjectName}-CodePipeline"

  # S3 location of the deployment configuration files
  # This contains the taskdef.json and appspec.yaml used by CodeDeploy
  # Useful for debugging deployment issues or manual deployments
  CodeDeployFilesArtifactS3Uri:
    Description: "S3 URI for CodeDeploy Files Artifact"
    Value: !GetAtt CodeDeployFilesArtifact.S3Uri
    Export:
      Name: !Sub "${ProjectName}-CodeDeployFilesArtifactS3Uri"

  # S3 bucket where CodePipeline stores all its artifacts
  # This includes source artifacts, build artifacts, and deployment configs
  # Useful for troubleshooting pipeline issues or manual artifact inspection
  ArtifactsBucketName:
    Description: "S3 Bucket for CodePipeline artifacts"
    Value: !Ref CodePipelineArtifactsBucket
    Export:
      Name: !Sub "${ProjectName}-ArtifactsBucket"
